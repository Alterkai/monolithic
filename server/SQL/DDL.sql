-- Created by Vertabelo (http://vertabelo.com)
-- Optimized for PostgreSQL by Gemini
-- Last modification date: 2025-07-01 07:14:00.000

-- tables

-- Table: role
CREATE TABLE role (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(25) NOT NULL UNIQUE,
    description VARCHAR(255) NULL
);

-- Table: users
CREATE TABLE users (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    avatar TEXT NULL,
    username VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    status BOOLEAN NOT NULL DEFAULT TRUE,
    date_joined TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Table: user_role (Junction table)
CREATE TABLE user_role (
    user_ID INT NOT NULL,
    role_ID INT NOT NULL,
    PRIMARY KEY (user_ID, role_ID),
    CONSTRAINT fk_user_role_user FOREIGN KEY (user_ID) REFERENCES users (ID) ON DELETE CASCADE,
    CONSTRAINT fk_user_role_role FOREIGN KEY (role_ID) REFERENCES role (ID) ON DELETE CASCADE
);

-- Table: manga
CREATE TABLE manga (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title VARCHAR(100) NOT NULL,
    original_title VARCHAR(100) NULL,
    description TEXT NOT NULL,
    author VARCHAR(50) NOT NULL,
    cover TEXT NOT NULL,
    ratings NUMERIC(3, 1) NOT NULL DEFAULT 8.0,
    CONSTRAINT uq_title UNIQUE (title)
);
CREATE INDEX idx_manga_title ON manga(title);

-- Table: genre
CREATE TABLE genre (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE
);

-- Table: manga_genre (Junction table)
CREATE TABLE manga_genre (
    manga_ID INT NOT NULL,
    genre_ID INT NOT NULL,

    -- Primary Key komposit untuk memastikan setiap pasangan manga-genre unik.
    PRIMARY KEY (manga_ID, genre_ID),

    -- Foreign Key yang menghubungkan ke tabel 'manga'.
    -- Jika sebuah manga dihapus, semua relasinya di sini juga akan terhapus.
    CONSTRAINT fk_manga_genre_manga
        FOREIGN KEY (manga_ID)
        REFERENCES manga (ID)
        ON DELETE CASCADE,

    -- Foreign Key yang menghubungkan ke tabel 'genre'.
    -- Jika sebuah genre dihapus, semua relasinya di sini juga akan terhapus.
    CONSTRAINT fk_manga_genre_genre
        FOREIGN KEY (genre_ID)
        REFERENCES genre (ID)
        ON DELETE CASCADE
);

-- Table: chapter
CREATE TABLE chapter (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    number NUMERIC(5, 1) NOT NULL,
    name VARCHAR(100) NULL,
    date_added TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    manga_ID INT NOT NULL,
    CONSTRAINT fk_chapter_manga FOREIGN KEY (manga_ID) REFERENCES manga (ID) ON DELETE CASCADE,
    UNIQUE (manga_ID, number)
);

-- Table: image
CREATE TABLE image (
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    page_number INT NOT NULL,
    link TEXT NOT NULL,
    chapter_ID INT NOT NULL,
    CONSTRAINT fk_image_chapter FOREIGN KEY (chapter_ID) REFERENCES chapter (ID) ON DELETE CASCADE,
    -- Setiap halaman dalam satu chapter harus unik
    UNIQUE (chapter_ID, page_number)
);

-- Table: bookmark
CREATE TABLE bookmark (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    last_read_chapter_id INT NOT NULL,
    date_added TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    user_ID INT NOT NULL,
    manga_ID INT NOT NULL,
    CONSTRAINT fk_bookmark_user FOREIGN KEY (user_ID) REFERENCES users (ID) ON DELETE CASCADE,
    CONSTRAINT fk_bookmark_manga FOREIGN KEY (manga_ID) REFERENCES manga (ID) ON DELETE CASCADE,
    CONSTRAINT fk_bookmark_last_read_chapter FOREIGN KEY (last_read_chapter_id) REFERENCES chapter(ID) ON DELETE CASCADE
);

-- Table: manga_comments
CREATE TABLE manga_comments (
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    comment TEXT NOT NULL,
    date_added TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    manga_ID INT NOT NULL,
    user_ID INT NOT NULL,
    CONSTRAINT fk_manga_comments_manga FOREIGN KEY (manga_ID) REFERENCES manga (ID) ON DELETE CASCADE,
    CONSTRAINT fk_manga_comments_user FOREIGN KEY (user_ID) REFERENCES users (ID) ON DELETE CASCADE
);

-- Table: chapter_comments
CREATE TABLE chapter_comments (
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    comment TEXT NOT NULL,
    date_added TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    chapter_ID INT NOT NULL,
    user_ID INT NOT NULL,
    CONSTRAINT fk_chapter_comments_chapter FOREIGN KEY (chapter_ID) REFERENCES chapter (ID) ON DELETE CASCADE,
    CONSTRAINT fk_chapter_comments_user FOREIGN KEY (user_ID) REFERENCES users (ID) ON DELETE CASCADE
);

-- Table: salary (Tabel untuk staff)
CREATE TABLE salary (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    payment_date DATE NOT NULL,
    amount NUMERIC(10, 2) NOT NULL,
    user_ID INT NOT NULL,
    -- Mengubah ke CASCADE. Data gaji tanpa pemilik tidak berguna.
    CONSTRAINT fk_salary_user FOREIGN KEY (user_ID) REFERENCES users (ID) ON DELETE CASCADE
);

-- Tipe kustom untuk status tugas
CREATE TYPE task_status AS ENUM (
    'pending',
    'in_progress',
    'completed'
);

-- Table: task (Tugas untuk staff)
CREATE TABLE task (
    ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    date_added TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    status task_status NOT NULL DEFAULT 'pending',
    user_ID INT NOT NULL,
    manga_ID INT NOT NULL,
    CONSTRAINT fk_task_user FOREIGN KEY (user_ID) REFERENCES users (ID) ON DELETE CASCADE,
    CONSTRAINT fk_task_manga FOREIGN KEY (manga_ID) REFERENCES manga (ID) ON DELETE CASCADE
);

---
-- Fungsi Trigger: add_member_role_on_new_user
-- Menambahkan peran 'member' ke user_role setiap kali pengguna baru dibuat.
---
CREATE OR REPLACE FUNCTION add_member_role_on_new_user()
RETURNS TRIGGER AS $$
DECLARE
    member_role_id INT;
BEGIN
    -- Dapatkan ID dari peran 'member'
    SELECT ID INTO member_role_id FROM role WHERE name = 'Member';

    -- Periksa apakah peran 'member' ditemukan
    IF member_role_id IS NOT NULL THEN
        -- Masukkan entri baru ke tabel user_role
        -- NEW.ID merujuk pada ID dari baris baru yang baru saja dimasukkan ke tabel users
        INSERT INTO user_role (user_ID, role_ID)
        VALUES (NEW.ID, member_role_id);
    ELSE
        -- Opsional: Log atau tampilkan pesan jika peran 'member' tidak ditemukan
        RAISE WARNING 'Role "member" not found. Cannot assign default role to new user ID: %', NEW.ID;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

---
-- Trigger: trg_add_member_role
-- Mengaktifkan fungsi add_member_role_on_new_user setelah setiap INSERT di tabel users.
---
CREATE TRIGGER trg_add_member_role
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION add_member_role_on_new_user();

-- End of file.

-- VIEW: get manga with chapters
CREATE OR REPLACE VIEW manga_with_chapters AS
SELECT
    m.ID AS manga_id,
    m.title AS manga_title,
    m.original_title AS manga_original_title,
    m.description AS manga_description,
    m.author AS manga_author,
    m.cover AS manga_cover,
    m.ratings AS manga_ratings,
    COALESCE(
        JSONB_AGG(
            JSONB_BUILD_OBJECT(
                'id', c.ID,
                'number', c.number,
                'name', c.name,
                'date_added', c.date_added
            )
            ORDER BY c.number ASC
        ) FILTER (WHERE c.ID IS NOT NULL),
        '[]'::JSONB
    ) AS chapters
FROM
    manga m
LEFT JOIN
    chapter c ON m.ID = c.manga_ID
GROUP BY
    m.ID, m.title, m.original_title, m.description, m.author, m.cover, m.ratings
ORDER BY
    m.ID;

-- VIEW: get chapter with images
CREATE OR REPLACE VIEW chapter_with_images AS
SELECT
    m.title AS manga_title,
    c.ID AS chapter_id,
    c.number AS chapter_number,
    c.name AS chapter_name,
    c.date_added AS chapter_date_added,
    c.manga_ID AS chapter_manga_id,
    COALESCE(
        JSONB_AGG(
            JSONB_BUILD_OBJECT(
                'id', i.ID,
                'page_number', i.page_number,
                'link', i.link
            )
            ORDER BY i.page_number ASC 
        ) FILTER (WHERE i.ID IS NOT NULL),
        '[]'::JSONB 
    ) AS images
FROM
    chapter c
LEFT JOIN
    image i ON c.ID = i.chapter_ID
JOIN
    manga m ON c.manga_ID = m.ID
GROUP BY
    c.ID, c.number, c.name, c.date_added, c.manga_ID, m.title
ORDER BY
    c.ID;

-- VIEW: get chapter with comments
CREATE OR REPLACE VIEW chapter_with_comments AS
SELECT
    c.ID AS chapter_id,
    c.number AS chapter_number,
    c.name AS chapter_name,
    c.date_added AS chapter_date_added,
    c.manga_ID AS chapter_manga_id,
    COALESCE(
        JSONB_AGG(
            JSONB_BUILD_OBJECT(
                'id', cc.ID,
                'comment', cc.comment,
                'date_added', cc.date_added,
                'user_id', cc.user_ID,
                'user_name', u.name
            )
            ORDER BY cc.date_added ASC 
        ) FILTER (WHERE cc.ID IS NOT NULL),
        '[]'::JSONB 
    ) AS comments
FROM
    chapter c
LEFT JOIN
    chapter_comments cc ON c.ID = cc.chapter_ID
LEFT JOIN
    users u ON cc.user_ID = u.ID
GROUP BY
    c.ID, c.number, c.name, c.date_added, c.manga_ID
ORDER BY
    c.ID;

-- VIEW: get manga with comments
CREATE OR REPLACE VIEW manga_with_comments AS
SELECT
    m.ID AS manga_id,
    m.title AS manga_title,
    m.original_title AS manga_original_title,
    m.description AS manga_description,
    m.author AS manga_author,
    m.cover AS manga_cover,
    m.ratings AS manga_ratings,
    COALESCE(
        JSONB_AGG(
            JSONB_BUILD_OBJECT(
                'id', mc.ID,
                'comment', mc.comment,
                'date_added', mc.date_added,
                'user_id', mc.user_ID,
                'user_name', u.name,
                'user_avatar', u.avatar
            )
            ORDER BY mc.date_added ASC 
        ) FILTER (WHERE mc.ID IS NOT NULL),
        '[]'::JSONB 
    ) AS comments
FROM
    manga m
LEFT JOIN
    manga_comments mc ON m.ID = mc.manga_ID
LEFT JOIN
    users u ON mc.user_ID = u.ID
GROUP BY
    m.ID, m.title, m.original_title, m.description, m.author, m.cover, m.ratings
ORDER BY
    m.ID;

-- FUNCTION: add manga genre
-- This function adds a genre to a manga. If the genre does not exist, it will
CREATE OR REPLACE FUNCTION add_manga_genre(
    p_manga_id INT,
    p_genre_name VARCHAR(50)
)
RETURNS VOID AS $$
DECLARE
    v_genre_id INT;
BEGIN
    INSERT INTO genre (name)
    VALUES (LOWER(p_genre_name))
    ON CONFLICT (name) DO UPDATE SET
        name = EXCLUDED.name
    RETURNING ID INTO v_genre_id;

    INSERT INTO manga_genre (manga_ID, genre_ID)
    VALUES (p_manga_id, v_genre_id)
    ON CONFLICT (manga_ID, genre_ID) DO NOTHING;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Gagal menambahkan genre "%" ke manga ID %: %', p_genre_name, p_manga_id, SQLERRM;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE VIEW bookmark_with_manga AS
SELECT
    b.ID,
    b.last_read_chapter_id as last_read_chapter,
    b.date_added,
    b.user_ID,
    b.manga_ID,
    m.title AS manga_title,
    m.original_title AS manga_original_title,
    m.description AS manga_description,
    m.author AS manga_author,
    m.cover AS manga_cover,
    m.ratings AS manga_ratings
FROM
    bookmark b
JOIN
    manga m ON b.manga_ID = m.ID
ORDER BY
    b.date_added DESC; -- Mengurutkan bookmark terbaru terlebih dahulu

CREATE OR REPLACE VIEW manga_latest_chapters AS
SELECT
    m.ID AS manga_id,
    m.title AS manga_title,
    m.original_title AS manga_original_title,
    m.description AS manga_description,
    m.author AS manga_author,
    m.cover AS manga_cover,
    m.ratings AS manga_ratings,
    c.ID AS chapter_id,
    c.number AS chapter_number,
    c.name AS chapter_name,
    c.date_added AS chapter_date_added
FROM
    manga m
LEFT JOIN (
    SELECT
        c.manga_ID,
        c.ID,
        c.number,
        c.name,
        c.date_added,
        ROW_NUMBER() OVER (PARTITION BY c.manga_ID ORDER BY c.date_added DESC
        ) AS rn
    FROM
        chapter c
) c ON m.ID = c.manga_ID AND c.rn = 1
ORDER BY
    m.ID, c.date_added DESC;

CREATE OR REPLACE VIEW manga_latest_chapters_with_genres AS
SELECT
    m.ID AS manga_id,
    m.title AS manga_title,
    m.author AS manga_author,
    m.cover AS manga_cover,
    lc.chapter_number AS chapter_number,
    -- Mengumpulkan genre ke dalam array JSON
    COALESCE(
        (
            SELECT
                JSON_AGG(
                    JSON_BUILD_OBJECT('id', g.ID, 'name', g.name)
                    ORDER BY g.name -- Urutkan genre berdasarkan nama dalam array
                )
            FROM
                manga_genre mg
            JOIN
                genre g ON mg.genre_ID = g.ID
            WHERE
                mg.manga_ID = m.ID
        ),
        '[]'::json -- Jika tidak ada genre, kembalikan array kosong JSON
    ) AS genres
FROM
    manga m
LEFT JOIN (
    -- Subquery untuk mendapatkan chapter terbaru untuk setiap manga
    SELECT
        c.manga_ID,
        c.ID AS chapter_id,
        c.number AS chapter_number,
        c.name AS chapter_name,
        c.date_added AS chapter_date_added,
        ROW_NUMBER() OVER (PARTITION BY c.manga_ID ORDER BY c.date_added DESC) AS rn
    FROM
        chapter c
) lc ON m.ID = lc.manga_ID AND lc.rn = 1
ORDER BY
    m.ID;